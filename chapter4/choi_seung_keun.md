# 스트림의 게으름이란 무엇이고 루프퓨전은 무엇인가?

### 스트림의 게으름이란?

스트림의 데이터 처리 시점은 이론적으로 요청일 들어왔을 때만 요소를 연산한다. 즉 지연 연산의 특징을 가지고 있으며 실행 결과가 필요한 시점에 실행한다.

### Lazy 방식

- 결과 값이 필요할 때까지 계산을 늦춤
- 내부 준비 작업이 필요하므로 무조건 효율적이라고 보기 어려움

### eager 방식

- 실행할 코드가 보이는 순간 곧바로 실행
- 실행 결과가 향후 필요하다는 점이 확실하다면 성능 측면에서 우월할 수도 있음

### 루트 퓨전이란

파이프라인에서 복수의 스트림 연산을 하나의 연산 과정을 병합하는 것

- 스트림 연산과정
    
    ```jsx
    members.stream().
        .filter(...) // 중간연산
        .map(...) // 중간연산
        .limit(...) // 중간연산
        .collect(toList()); // 최종연산
    ```
    
    - 스트림의 연산은 중간 연산과 최종연산이 있는데 중간연산은 단말 연산을 파이프라인에 실행하기 전까지 아무 연산도 실행하지 않음 ⇒ 중간 연산 모두 합친 후 최종 연산으로 처리
    - filter, map, limit 순차적으로 수행하는 것이 아닌 하나의 연산으로 수행 ⇒ 루프퓨전

### 참고자료

- [[Java] 스트림: 지연 연산과 최적화](https://bugoverdose.github.io/development/stream-lazy-evaluation/)
</br>

# 스트림에서 병렬처리는 어떻게 이루어질까?

### 스트림과 병렬화

- JDK7 부터 포크/조인 프레임워크 이용해서 병렬화 사용
- 스트림에서 병렬화 하는 방법
    - 컬렉션 - `parallelSteam()` 호출 시병렬스트림 생성
    - 배열, 그 외 요소 - `stream().parallel()` 호출 시 병렬 스트림 생성

- 병렬스트림이란?
    
    각 스레드에서 처리할 수 있도록 요소를  여러 청크로 분할한 스트림이다.
    
- 리듀싱이란?
    
    모든 스트림 요소를 처리하여 값으로 도출하는 연
    

### 성능 비교

```jsx
/**
 * 반복형, 스트림 사용x
 */
public long iterativeSum(long n) {
    long result = 0;
    for (long i = 1L; i <= n; i++) {
        result += i;
    }
    return result;
}
```

```jsx
/**
 * 순차 리듀싱
 */
public long sequentialSum(long n) {
    return Stream.iterate(1L, i -> i + 1)
            .limit(n)
            .reduce(0L, Long::sum);
}
```

```jsx

/**
 * 병렬 리듀싱
 */
public long parallelSum(long n) {
    return Stream.iterate(1L, i -> i + 1)
            .limit(n)
            .parallel() // 스트림을 병렬 스트림으로 변환한다.
            .reduce(0L, Long::sum);
}
```

- 일반적인 사용으로 stream 메서드(순차스트림), parallelStream 메서드(병렬 스트림)의 차이가 없는 결과를 가진다.
- 잘못된 사용 시 **오히려 순차 스트림, 병렬 스트림 방법이 느릴 수 있다.**
    - 성능 비교 관련해서는 참고자료 참고
    

### 잘못된 사용 시 성능이 느린 이유

- 문제점
    1. 반복 결과로 박싱된 객체 생성되며 언박싱 과정 거침
    2. 리듀싱 과정을 시작하는 시점에서 전체 숫자리스트(요소)가 준비되지 않았기 떄문에 병렬 처리를 위한 청크로 분할할 수 없다. 
        
        ⇒ 실질적으로 순차 처리 방식과 다르지 않기 때문 ⇒ 결론적 병렬 처리를 위한 오버헤드만 증가 
        
- 해결 방법
    1. 박싱, 언박싱 문제
        - 특화된 스트림 / 특화된 메서드 사용 ⇒ Stream 대신 LongStream 사용
    2. 요소 준비의 문제
        - range, rangeClosed 메서드 사용  ⇒ 특정 범위의 인덱스를 준비함으로써 청크 분할할 수 있는 숫자 범위 생산
- 고려할점
    - 병렬화를 사용하기 위해 여러 조건을 맞추고 올바른 자료구조를 선택 할 것
    - 병렬화를 올바르게 사용하고 있는지 검증 필요

### 병렬처리 내부

- 병렬 처리로 인해 데이터가 올바른 값이 나오지 않을 수 있음
    - 여러 스레드에서 동시에 누적자를 실행하기 때문에 공유 자원 상태를 변경에 주의
- PC나 서버 코어 수에 따라서 스레드 생성
    - 코어 수를 계산하여 스레드 자동 생성
- main 스레드는 1개이고 그 외는 ForkJoinPool로 생성
    - main : 스트림 처리를 위한 기본 스레드
    - main 스레드가 ForkJoinPool 생성

### 포크 조인이란

- 포크 조인 프레임 워크는 병렬화 할 수 있는 작업을 재귀적으로 작은 작업들로 쪼개서 분할, 분할한 서브 작업(task)들이 작업 수행한 각각의 결과를 합쳐 전체 결과를 만들도록 설계
- 하나의 작업을 작은 단위로 나워서 여러 스레드 동시 처리 쉽도록 해줌
- 서브 작업을 스레드 풀(ForkJoinPool)의 작업자 스레드에 분산 할당하는 ExecuterService 인터페이스 구현
![image](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f7fb74a7-74ed-4477-9c2f-64335835e216/Untitled.png)

### RecursiveTask 활용

- 스레드 풀 이용하기 위해 RecursiveTask<R> 서브 클래스를 만들어야 한다.
- R은 병렬화된 태스크가 생성하는 결과 형식, 결과가 없을때 RecursiveAction 형식
- RecursiveTask 구현하려면 추상메서드 compute() 구현
- compute 메서드는 서브 태스크로 분할하는 로직과 더 이상 분할할 수 없을 때 개별 서브 태스크의 결과를 생산할 알고리즘 정의

참고자료
- [[Stream API 병렬 데이터 처리하기]](https://catsbi.oopy.io/0428be55-8c8d-40a2-923a-acc738d74a14)
- [[JAVA8 병렬프로그래밍] 스트림 병렬처리](https://devfunny.tistory.com/810)

</br>

# 스트림 사용 시 주의할 점에는 무엇이 있을까?

### 1. 스트림 재사용 문제

스트림은 한 번만 사용되고 소비되기 때문에 다시 사용할 경우 오류가 발생한다. ⇒ 

### 2. 지역 변수 접근

스트림을 이용하면서 람다, 메소드 참조의 경우 지역 변수를 접근할 수 없음

### 3. 무한 스트림 생성 문제

- 루프 퓨전이 적용되지 않아 무한 스트림 생성되는 문제가 발생할 수 있음
- `distinct()` , `sorted()` 메서드는 `stateful 연산`은 지연 연산을 무효화시킴
    
    ```jsx
    Stream.iterate(0, i -> (i + 1) % 2)
    	.distinct()
    	.limit(10)
    	.forEach(System.out::println);
    
    System.out.println("Complete!!");	//무한 스트림으로 인해 도달하지 못함
    ```
    
    - distinct 연산은 오직 0,1 이라는 값만 생성할 것이라는 것을 알지 못해 무한히 값을 받아들여 사
- 해결방법
    - 무한 스트림에 대해 limit(10)으로 10개 데이터 고르고, distinct() 중복 제거

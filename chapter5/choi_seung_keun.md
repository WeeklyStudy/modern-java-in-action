# Q. findFirst()와 findAny()의 차이점은 무엇이고 언제 사용하는 것이 좋을까?

### 공통점

- Stream에서 조건에 일치하는 요소 1개를 Optional로 리턴
- 일치하는 요소 없다면 empty 리턴

### 차이점

- findFirst()는 조건에 일치하는 요소 중 가장 앞에 있는 요소를 반환하고, findAny()는 가장 먼저 탐색되는 임의의 요소를 반환한다.
    
    ⇒ 요소의 순서의 차이를 가지고 있음
    
    ⇒ 병렬처리에서 순서는 다른 결과를 만듦
    

### 사용하는 시점

반환하는 요소의 순서의 차이를 가지고 있기에 다르게 사용

- 병렬 처리에서 첫 번째 요소 검색 어려움
- 병렬 처리를 사용할 때 순서에 상관없이 가장 먼저 탐색된 요소를 반환하는 findAny() 사용

</br>

# Q. flatMap 이란 무엇이고, 어떤 상황에서 사용하면 좋을까?

### flatMap 메서드

- 스트림의 형태가 배열과 같을 때 모든 요소를 단일 요소 스트림으로 반환
    
    ```java
    String[][] namesArray = new String[][]{
            {"kim", "taeng"}, {"mad", "play"},
            {"kim", "mad"}, {"taeng", "play"}};
            
    Set<String> namesWithFlatMap = Arrays.stream(namesArray)
            .flatMap(innerArray -> Arrays.stream(innerArray))
            .filter(name -> name.length() > 3)
            .collect(Collectors.toSet());
            
    // play, taeng 출력
    namesWithFlatMap.forEach(System.out::println);
    ```
    
- 사용하면 좋은 경우
    
    스트림의 형태가 배열인 경우 또는 입력된 값을 또 다시 스트림의 형태로 반환하고자 할 때 유용

</br>

# Q. 상태있음과 상태없음은 병렬 처리에서 어떤 연관성이 있을까?

## 스트림 연산의 특징

- 상태를 갖는 연산과 상태를 갖지 않는 연산이 있다.
- 무한 스트림을 요소로 받는 연산과 유한 스트림을 연산으로 받는 연산이 있다.
    - 언바운드 스트림 = 무한 스트림
    - 바운드 스트림 = 유한 스트림
- 예시
    - map, filter는 상태가 없는 연산
    - reduce, sorted, distinct는 상태를 가진 바운드
    - limit, skip은 상태를 가진 언바운드

## 병렬 처리와 상태의 연관성

### 공유 변수란?

공유 변수는 여러 스레드에서 동시에 엑세스하고 수정할 수 있는 변수

- 스트림은 공유 변수에 액세스하고 수정 가능
- 공유 변수 사용 시 병렬처리에서 경쟁 조건 및 동시성 관련 문제가 발생할 가능성이 있다

### 문제점

병렬 스트림에서 공유 변수 처리시 경쟁조건 및 기타 동시성 관련 문제가 발생할 가능성이 있음

⇒ 여러 스레드가 동시에 공유변수에 액세스하고 수정은 올바른 데이터를 출력하지 않음

### 해결방법

1. 상태를 가지면 생기는 부작용을 없앤다.
2. 올바른 결과를 얻기 위한 불변 상태 기법 사용 ⇒ 18, 19장 학습
- 불변성:
    - 변수를 불변으로 만드는 것
    - 공유 변수를 변경할 수 없도록 함으로써 동시 수정 가능성을 제거
- 비간섭
    - 스트림 작업은 처리 중에 공유 변수를 수정하지 않게 함
    - 기본 데이터 원본이나 공유 변수를 수정하지 않고 새로운 스트림이나 결과를 생성
- 동기화
    - 공유 변수 수정해야 하는 경우 동기화 매커니즘 사용하여 조정을 보장
    - 원자 변수, 락 과 같은 기술 사용

# 옵저버 패턴이란?

> 객체(주체) 상태 변화를 관찰하는 관찰자(옵저버) 목록을 객체에 등록하여 주체의 상태변화가 있을 때마다 메서드를 통해 목록의 옵저버에게 통지하도록 하는 디자인 패턴

> 어떤 객체의 상태가 변할 때 그와 연관된 객체들에게 알림을 보내는 패턴

- 분산 이벤트 핸들링 시스템 구현에 사용
- 발행/구독 모델

### 구현 원리

옵저버(리스너)라 불리는 하나 이상의 객체를 관찰 대상이 되는 객체에 등록시킨 후 각각의 옵저버들은 관찰 대상 객체의 상태 변화 발생 시 객체가 발생시키는 이벤트를 받아 처리 
![image](https://github.com/WeeklyStudy/modern-java-in-action/assets/77659341/2d9af233-5494-4758-9e97-1d4853569e09)

- 이벤트가 발생하면 옵저버는 콜백을 받음
- 파생 옵저버는 `notify` 함수 구현하여 이벤트 발생 시 처리할 동작을 정의
- 상속을 통한 구현이 아닌 구성을 이용해 인터페이스를 포함 하는 방식으로 구현
- 옵저버 패턴이 많은 쓰인 시스템에는 재귀 호출 막는 매커니즘 필요

### 옵저버 패턴의 장단점

- 장점
    - 실시간으로 한 객체의 변경사항을 다른 객체에 전파 가능
    - 느슨한 결합으로 시스템의 유연하게 만들고 객체간의 의존성을 제거할 수 있음
- 단점
    - 너무 많이 사용할 경우 상태 관리 힘들어질 수 있음
    - 데이터 배분 문제가 발생하면 큰 문제로 발전할 가능성 있음

### 참고자료
- [옵저버 패턴*](https://velog.io/@octo__/%EC%98%B5%EC%A0%80%EB%B2%84-%ED%8C%A8%ED%84%B4Observer-Pattern)

</br>

# 디자인 패턴들을 어떤 방법으로 분류할 수 있을까?
## 1. 디자인 패턴의 특징
- 콘텍스트, 문제, 해결의 구조를 가지고 있음
    - 콘텍스트: 문제 발생 상황 기술 → 패턴 적용될 수 있는 상황 나타냄
    - 문제 : 패턴 적용하여 해결될 필요 있는 이슈들을 기술
    - 해결 : 문제 해결하는 설계 구성하는 요소와 요소 사이의 관계, 책임, 협력 관계를 기술
- 다양한 디자인 패턴이 발견되었고 23 가지 디자인 패턴으로 정리하였음

## 2. 패턴의 분류

### 2.1 디자인 패턴 분류가 필요한 이유

위와 같이 다양한 디자인 패턴이 발견

- 패턴들 중에서 상황에 맞는 디자인 패턴 찾아내야 함
- 같은 그룹에 속하는(유사한) 패턴끼리 비교가 용이해야 함

주요 분리 기준은 `목적`, `범위`이다.

### 2.2 목적에 따라 분류

생성, 구조, 행위 중의 한 가지 목적을 가짐
![image](https://github.com/WeeklyStudy/modern-java-in-action/assets/77659341/dc3290f4-f12f-442a-a807-d326988efd91)

- 생성 패턴 : 객체의 생성 과정에 관여
    
    객체의 생성, 조합을 캡슐화하여 특정 객체 생성, 변경되어도 프로그램 구조에 영향을 받지 않도록 유연성 제공
    
- 구조 패턴 : 클래스나 객체를 조합해 더 큰 구조를 만드는 패턴
    
    서로 다른 인터페이스를 지닌 객체를 묶어 단일 인터페이스 제공, 객체를 묶어 새로운 기능 제공
    
- 행위 패턴 : 클래스나 객체들이 상호작용(알고리즘)이나 책임을 분산에 관련된 패턴
    
    한 객체가 수행할 수 없는 작업을 여러 개의 객체로 어떻게 분배하는지, 객체 사이 결합도 최소화하는 것에 중점
    

### 2.3 범위에 따라 분류

클래스에 적용하는지 객체에 적용하는지 구분

- 클래스 패턴 : 클래스들과 서브 클래스 간의 관련성(주로 상속)을 다루는 패턴으로 컴파일 시점에 정적으로 결정
- 객체 패턴 : 객체의 관련성을 다루는 패턴으로 런타임 시 동적으로 변경 가능

클래스 패턴으로 정의한 패턴만이 클래스 관련성 이용, 일부만이 클래스 패턴, 대부분이 객체 패턴 영역에 속함

![image](https://github.com/WeeklyStudy/modern-java-in-action/assets/77659341/c81d7566-0e1f-468e-a811-e745f119a82b)
- 생성-클래스 패턴 : 객체를 생성하는 책임의 일부를 서브 클래스가 담당
- 생성-객체 패턴 : 객체를 생성하는 책임을 다른 객체에 위임
- 구조-클래스 패턴 : 상속을 이용해서 클래스 합성
- 구조-객체 패턴 : 객체를 합성하는 방법을 정의
- 행위-클래스 패턴 : 상속을 이용해서 알고리즘의 흐름을 기술
- 행위-객체 패턴 : 하나의 업무를 수행하기 위해 객체 집합이 어떻게 협력하는지 기술

### 2.4 참조 관계에 따라 관리

패턴들은 다양한 참조 관계를 가지고 있고 관계에 따라 분류 가능
![image](https://github.com/WeeklyStudy/modern-java-in-action/assets/77659341/6ad162a1-4d18-4929-a692-ccacfcf9df55)
> 디자인 패턴의 관계도

![image](https://github.com/WeeklyStudy/modern-java-in-action/assets/77659341/b978c3be-c460-4575-8548-1227acdf2c42)
> 관계정의

`관계 정의를 통해 디자인 패턴의 관계도 이해`
- Facade 패턴은 Singleton 패턴을 통해 구현된 인스턴스를 이용하고, Singleton 패턴은 Facade 패턴에 사용됨
- Singleton 패턴은 Abstract Factory 패턴, Facade 패턴에 사용됨
- Abstract Factory 패턴은 Prototype 패턴을 이용되기 때문에 Prototype 패턴은 Abstract Factory 패턴의 대안으로 사용될 수 있음
- 일부 패턴들은 함께 사용되는 경우도 있음
    - Composite 패턴은 대부분 Iterator 패턴, Visitor 패턴과 함께 사용
- Composite 패턴과 Decorator 패턴의 경우 의도는 다르지만 유사한 구조를 가지고 있음

**디자인 패턴간의 관계에 따라 분류를 하려면 각 패턴의 목적과 구조를 잘 알고 있어야 함**

### 참고자료
- [디자인 패턴의 조직화 관계도](https://soopiri.tistory.com/6)
- [[디자인패턴] 디자인패턴의 참조 관계도](https://m.blog.naver.com/jvioonpe/220247760303)

</br>

# 의무 체인 패턴의 장단점은 무엇이고, 어떤 상황에서 활용되는가?

### 의무 체인 패턴(책임 연쇄 패턴)

> 클라이언트로부터의 요청을 처리할 수 있는 처리객체를 집합(Chain)으로 만들어 부여함으로 결합을 느슨하기 위해 만들어진 디자인 패턴

- 요청을 처리할 수 있는 객체를 찾을 때 까지 집합 안에서 요청을 전달
- 많이 사용되는 패턴
- 처리 객체가 여러 개이고 처리 객체가 특정적이지 않을 경우 권장

### 구현원리

서로 다른 작업을 처리할 수 있는 객체를 연결시키고, 작업이 들어오면 자신이 처리할 수 있는 일 수행 후, 다음으로 넘기는 방식
![image](https://github.com/WeeklyStudy/modern-java-in-action/assets/77659341/4cf0f701-3c74-426b-9fb5-a8007fbfaecc)

- 필요 메서드
    - 다음 작업을 처리할 객체를 지정하는 메서드
    - 내가 처리해야 하는 메서드

### 의무 체인 패턴의 장단점

- **장점**
    - 결합도를 낮추며, 요청의 발신자와 수신자를 분리
    - 클라이언트는 처리 객체의 집합 내부의 구조를 알지 못함
    - 집합 내의 처리 순서를 변경, 처리 객체를 추가, 삭제 가능하여 유연성 향상
    - 새로운 요청에 대한 처리 객체 생성 편리
- **단점**
    - 충분한 디버깅을 거치지 않을 경우 집합 내부에서 사이클이 발생 가능
    - 디버깅, 테스트가 쉽지 않음

### 참고 자료

- ****[[디자인 패턴] 책임 연쇄 패턴(Chain of Responsibility Pattern)](https://always-intern.tistory.com/1)****

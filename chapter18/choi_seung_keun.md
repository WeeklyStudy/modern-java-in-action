# Q. 불변 객체란?

## 1. 불변성

### 1.1 함수형 프로그래밍과 불변성

함수형 프로그래밍은 수학적 함수의 계산으로 취급하고 상태와 가변 데이터를 멀리하는 프로그래밍 패러다임으로 함수의 응용을 강조함

따라서 함수형 프로그래밍에서는 생성된 값이 변하지 않는 불변성을 지키며 개발함

### 1.2 불변성

생성된 값(상태)를 변하지 않는 것을 의미

- 무분별한 값에 접근과 수정으로 디버깅 힘들어지는 상황과 부작용 막기 위함
- 메모리에 저장된 값을 변경하는 모든 행위에 해당
- 변수의 재할당 같은 행위도 포함
- 값의 변경이 일어나야 한다면 새로운 객체를 만들고 변경된 값을 할당
- 수학적 의미의 순수 함수의 형태로 함수를 생성

## 2. 불변 객체란?

### 2.1 불변 객체

객체 생성 이후 내부의 상태가 변하지 않는 객체

- 읽기 전용(read only) 메소드만 제공
- 내부 상태를 제공하는 메소드 제공하지 않거나 방어적 복사를 통해 제공
    - 방어적 복사 : 내부 상태 수정 시 해당 객체를 변경하는 것이 아닌 내부를 복사하여 전달하는 방법
- 대표적인 불변 객체
    - String
    - 기본 자료형 Wrapper 클래스 - Integer, Double
    - time 패키지 클래스 - LocalDate, LocalTime, LocalDateTime, ZonedDateTime, Duration, Period
    - Enum 클래스

### 2.2 불변 객체 사용 이유

1. 병렬 프로그래밍에 유용성, 동기화
    - 공유 자원이 불변이라면 항상 동일한 값을 반환
    - 멀티 스레드 환경에서 동시 쓰기에 대한 동기화 문제를 고려하지 않아도 됨
2. 실패 원자적인 메소드 생성
    - 어떠한 예외가 발생하여도 메소드 호출 전의 상태를 유지 가능
    - 오류 발생 시 오류가 발생하지 않은 것처럼 로직을 처리 가능
3. Cache, Map 또는 Set 등의 요소로 활용하기 적합
    - 값의 갱신을 고려하지 않기 때문에 캐시 등 데이터 저장 사용에 용이
4. 부수 효과를 피해 오류 가능성을 최소화
    - 부수효과로 인한 상태 파악은 유지보수성을 떨어뜨림
    - 불변 객체는 다른 메소드가 호출되어도 객체의 상태가 유지되기에 오류를 줄이고 유지 보수성 높은 코드를 작성하도록 도움
5. 다른 사람이 작성한 함수 예측 가능하며 안전하게 사용 가능
    - 값의 변하지 않음을 보장함으로써 안정성 있는 코드 사용 가능
6. 가비지 컬렉션의 성능을 높일 수 있음
    - 가비지 컬렉터가 스캔하는 객체의 수가 줄어들기 때문에 스캔하는 메모리 영역과 빈수도가 줄어듦
        
        ⇒ 지연 시간을 줄일 수 있음
        

## 3. 불변 객체 만드는 법

### 3.1 final 키워드

- final 키워드를 사용하여 불변성을 확보
    
    ```java
    final String name = "Old";
    ```
    

### 3.2 불변 클래스

불변 객체를 생성하기 위한 클래스 생성

- 클래스를 final 선언
- 모든 클래스 변수 private, final 선언
- 객체 생성을 위한 생성자, 정적 팩토리 메소드 추가
- 참조에 의해 변경 가능성 있을 경우 `방어적 복사` 이용

```java
public final class ImmutableClass {
    private final int age;
    private final String name;
    private final List<String> list;

    private ImmutableClass(int age, String name) {
        this.age = age;
        this.name = name;
        this.list = new ArrayList<>();
    }

    public static ImmutableClass of(int age, String name) {
        return new ImmutableClass(age, name);
    }
    
    public int getAge() {
        return age;
    }

    public String getName() {
        return name;
    }

    public List<String> getList() {
        return Collections.unmodifiableList(list);
    }
    
}
```

### 참고자료

- [[Java] 불변 객체(Immutable Object) 및 final을 사용해야 하는 이유](https://mangkyu.tistory.com/131)

</br>

# Q. 반복문과 재귀 방식의 차이점은 무엇이고 꼬리 재귀란 무엇인가?

## 1. 반복문과 재귀 방식 차이점

### 1.1 재귀함수란?

재귀함수 : 자기 자신을 호출하여 재참조하는 구조의 함수

- 피보나치, 하노이탑, 팩토리얼 알고리즘에서 많이 사용
- 코드 가독성이 좋음
- 스택 메모리를 사용

### 1.2 차이점

- 반복문
    - 실행 : 일련의 명령을 반복
    - 체재 : 초기화, 조건, 명령문, 변수 업데이트 등 포함
    - 종료 : 특정 조건에 도달할 때까지 반복 실행
    - 무한 반복 : CPU 사이클을 반복적으로 사용
    - 속도 : 빠름
    - 가독성 : 코드의 길이를 길게 만들고 가독성이 떨어짐
    - 스택 메모리 : 스택 메모리 사용하지 않음
- 재귀 함수
    - 실행 : 함수 자체를 호출
    - 체재 : 종료조건만 지정(조건이 추가될 수 있음)
    - 종료 : 조건부는 함수 호출 본문에 포함되어 재귀를 실행하지 않고 강제 반환
    - 무한 반복 : 메모리를 사용하기 때문에 스택 오버플로우 발생
    - 속도 : 느림
    - 가독성 : 코드의 길이와 변수가 적어 가독성이 높음
    - 스택 메모리 : 함수 호출마다 로컬 변수, 매개변수 저장하는데 사용

## 2. 꼬리 재귀란 무엇인가?

### 2.1 꼬리 재귀

재귀 호출이 함수의 마지막 연산으로 수행되는 경우를 의미하는 함수형 프로그래밍에서 사용되는 재귀 함수의 형태

- 루프 최적화
    - 컴파일러나 인터프리터에서 루프로 최적화 될 수 있음
    - 함수 호출을 반복문으로 변환하여 스택 오버플로우 방지하고 성능 향상
- 스택 메모리 절약
    - 꼬리 재귀는 재귀 호출 후 현재 프레임을 스택에서 제거 ⇒ 스택 메모리 최소화
        
        ```java
        int factorial(int n, int result) {
            if (n <= 1) {
                return result;
            }
            return factorial(n - 1, n * result);
        }
        ```
        
        재귀 호출이후 추가 계산이 없으므로 최적화 가능
        
- 코드 간결성
    - 반복적인 패턴의 코드를 간결하게 표현 가능

### 2.2 꼬리 재귀 최적화

컴파일러 또는 인터프리터가 재귀 함수를 반복문으로 변환하여 스택 메모리 최소화하는 `프로그래밍 언어`, `컴파일러 최적화 기술`

- 작동 방식
    - 꼬리 호출
        
        재귀 호출을 함수 마지막에 두어 추가 작업을 수행하지 않도록 함
        
    - 스택 프레임 제거
        
        꼬리 재귀 함수에서 재귀 호출 이후 현재 함수의 스택 프레임 제거하여 메모리를 일정하게 유지하여 스택 오버 플로우 방지
        
    - 루프 변환
        
        재귀 함수를 루프로 변환하여 스택 프레임 사용하지 않고 반복적 호출
        

### 참고자료

- [재귀함수와 반복문의 차이](https://hazel-developer.tistory.com/173)
- [꼬리 재귀 최적화(Tail Recursion)](https://bozeury.tistory.com/entry/%EA%BC%AC%EB%A6%AC-%EC%9E%AC%EA%B7%80-%EC%B5%9C%EC%A0%81%ED%99%94Tail-Recursion)

</br>

# Q. 함수형 프로그래밍에서 부작용(Side Effect)와 참조 투명성은 무엇인가?

## 1. 함수형 프로그래밍의 부작용(Side Effect)이란?

### 1.1 부작용

해당 함수를 실행으로 함수 외부에 영향을 끼치거나 영향을 받는 것을 의미

- **`의도치 않은 결과`**를 의미
- 의도치 않게 외부 변수 참조하거나 외부 변수를 변경하는 종류의 코드를 의미
- 부작용이 많아지면 디버깅이 어려워짐
- 다중 스레드 환경에서 문제를 발생시킬 수 있음

### 1.2 부작용의 예시

- 변수의 값 변경
    - 함수 내에서 외부 변수 값을 변경하는 것
        
        ```java
        int total = 0;
        
        public void addTotal(int value) {
        	total += value;
        }
        ```
        
        - 외부 상태에 의존하고, 호출시 마다 total 의 값이 달라지게 됨
- 파일 쓰기
    - 파일을 쓰는 함수는 파일 시스템의 상태를 변경
    - 같은 입력 값으로 함수를 호출해도 파일의 내용이 변경됨
- 외부 서버와 통신을 위한 네트워크 요청
    - 외부 리소스에 의존하고 네트워크 상태나 연결 문제에 따라 결과가 달라짐
- 예외 발생
    - 프로그램의 제어 흐름을 변경하고 같은 결과를 반환하지 않음
- 랜덤 숫자 생성
    - Math.random() 등
    - 난수 생성 함수는 매번 다른 값을 반환

### 1.3 함수형 프로그래밍과 부작용

결론적으로 부작용은 의도치 않은 결과로 디버깅과 유지보수를 어렵게 함

- **함수형 프로그래밍의 목적**
    
    함수형 프로그래밍은 수학적 함수의 계산으로 취급하고 상태와 가변 데이터를 멀리하는 프로그래밍 패러다임
    
    - 상태와 가변 데이터로 인한 부작용을 최소화하고 함수의 동작을 예측 가능하게 만들어야 한다.
- 부작용이 없을 때 좋은 점
    - **디버깅이 수월하고 유지 보수가 쉬운 코드를 작성하기 좋음**
    - **코드를 안정적으로 만들고 다중 스레드에서도 문제가 발생하지 않음**

따라서 동일한 입력에 같은 결과를 반환함으로써 부작용이 없는 순수 함수를 이용하려고 함

## 2. 참조 투명성

함수에 동일한 입력에 대해 항상 동일한 출력을 생성하는 특성을 가짐

- 특징
    - 결과 예측 가능성
        - 동일한 인수에 대해 항상 동일한 결과를 반환
        - 코드를 이해하고 디버깅이 쉽다
    - 부작용 없음
        - 외부 상태에 의존하지 않으며 외부 상태를 변경하지 않기에 다른 부분에 영향을 주지 않음
    - 대체 가능성
        - 함수 호출 결과를 해당 함수의 호출로 대체 가능
        - 함수 호출 결과를 변수에 저장하거나 다른 함수의 인수로 전달할 수 있음을 의미
- 장점
    - 코드 가독성 향상 : 함수의 동작을 예상 가능하므로 코드의 의도가 명확해짐
    - 테스트 용이성 : 입력과 출력의 관계가 명확하기 때문에 결과를 예측하고 테스트 검증이 쉬워짐
    - 병렬화 가능성 : 함수 호출간의 상호 간섭이 없어 병렬 및 동시성 처리 용이
    - 최적화 가능성 : 호출 결과를 재사용하거나 인라인 처리 가능

### 참고 자료

- [**함수형 프로그래밍(Functional Programming)**](https://dawitblog.tistory.com/189)

